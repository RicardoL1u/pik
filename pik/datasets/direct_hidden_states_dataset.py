import pandas as pd
import numpy as np
import torch
from torch.utils.data import Dataset
import logging
import json
from collections import defaultdict
class DirectHiddenStatesDataset(Dataset):
    '''
    Loads the hidden states dataset and text generations from files generated by `generate.py`.
    '''
    def __init__(self,
        hs_file='hidden_states.pt',
        tg_file='text_generations.csv',
        precision=torch.float16,
        layer_idx=None, # None means all layers
        device='cuda',
    ):
        all_layers = layer_idx is None 
        
        hs = torch.load(hs_file, map_location=device).type(precision)
        assert hs.dim() in (2, 3)
        if all_layers and hs.dim() == 3:
            # HACK: to keep the fisrt half layers
            # hs = hs[:, :hs.shape[1] // 2, :]
            # HACK: to keep the middle half layers
            # hs = hs[:, hs.shape[1] // 4:hs.shape[1] // 4 * 3, :]
            hs = hs.reshape(hs.shape[0], hs.shape[1] * hs.shape[2])
        elif not all_layers and hs.dim() == 3:
            hs = hs[:, layer_idx, :]
            # HACK: to use the second last layer, we take the last layer of the reversed tensor
            # hs = hs[:, -2, :]
        self.hidden_states = hs
        logging.info('hidden_states.shape={}'.format(self.hidden_states.shape))
        self.text_generations:dict = json.load(open(tg_file, 'r'))
        
        # Compute mean evaluations for each 'hid' in a more efficient way
        evaluation_list = defaultdict(list)
        for _, row in enumerate(self.text_generations):
            evaluation_list[row['hid']].append(row['evaluation'])
        # calculate mean evaluations
        mean_evaluations = {hid: np.mean(evaluation_list[hid]) for hid in evaluation_list}
        # mean_evaluations = self.text_generations.groupby('hid')['evaluation'].mean().to_dict()
        
        # Create pik_labels using a vectorized operation
        self.pik_labels = np.array([mean_evaluations.get(hid, np.nan) for hid in range(self.hidden_states.shape[0])])
        # assert there is no nan in pik_labels
        assert not np.isnan(self.pik_labels).any(), 'pik_labels contains nan'
        assert len(self.pik_labels) == len(self.hidden_states), 'pik_labels len={} != hidden_states len={}'.format(len(self.pik_labels), len(self.hidden_states))
    def __len__(self):
        return self.hidden_states.shape[0]

    def __getitem__(self, i):
        return (
            self.hidden_states[i],
            self.pik_labels[i]
        )
  
    def get_pik_label(self, hid):
        return self.pik_labels[hid]